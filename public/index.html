<!DOCTYPE html>
<html lang="hi">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>рдкреНрд░рд╛рдЗрд╡реЗрдЯ рдХреЙрд▓</title>
  <style>
    body {
      font-family: 'Segoe UI', sans-serif;
      text-align: center;
      background: linear-gradient(135deg, #667eea, #764ba2);
      margin: 0; padding: 20px;
      color: white;
    }
    h1 { margin-bottom: 10px; }
    .status { font-size: 18px; margin-bottom: 20px; font-weight: bold; }
    .video-container { display: flex; justify-content: center; gap: 20px; margin-bottom: 20px; }
    video {
      width: 45%; max-width: 500px;
      border-radius: 15px;
      border: 3px solid rgba(255,255,255,0.3);
      box-shadow: 0 8px 20px rgba(0,0,0,0.3);
      background: black;
    }
    .controls { display: flex; flex-wrap: wrap; justify-content: center; gap: 10px; }
    button {
      padding: 12px 20px; font-size: 15px; border: none;
      border-radius: 25px; cursor: pointer; transition: 0.3s;
      font-weight: bold;
    }
    button:hover { transform: scale(1.05); }
    #video-call-btn { background: #00c853; color: white; }
    #audio-call-btn { background: #2196F3; color: white; }
    #end-btn { background: #f44336; color: white; display: none; }
    .extra { background: #333; color: white; display: none; }
  </style>
</head>
<body>
  <h1></h1>
  <div class="status" id="call-status">рдХреЛрдИ рдХреЙрд▓ рд╢реБрд░реВ рдирд╣реАрдВ рд╣реИ</div>

  <div class="video-container">
    <video id="local-video" autoplay muted playsinline></video>
    <video id="remote-video" autoplay playsinline></video>
  </div>

  <div class="controls">
    <button id="video-call-btn">ЁЯУ╣ рд╡реАрдбрд┐рдпреЛ рдХреЙрд▓</button>
    <button id="audio-call-btn">ЁЯОд рдСрдбрд┐рдпреЛ рдХреЙрд▓</button>
    <button id="end-btn">тЭМ рдХреЙрд▓ рд╕рдорд╛рдкреНрдд рдХрд░реЗрдВ</button>
    <!-- Extra Controls -->
    <button onclick="toggleFullScreen()">ЁЯУ║ Full Screen</button>

    <button id="mute-btn" class="extra">ЁЯФЗ рдореНрдпреВрдЯ</button>
    <button id="video-toggle-btn" class="extra">ЁЯУ╖ рдмрдВрдж</button>
    <button id="camera-switch-btn" class="extra">ЁЯФД рдХреИрдорд░рд╛</button>
    <button id="speaker-btn" class="extra">ЁЯФК рд╕реНрдкреАрдХрд░</button>
  </div>

  <script src="/socket.io/socket.io.js"></script>
  <script>
    const localVideo = document.getElementById('local-video');
    const remoteVideo = document.getElementById('remote-video');
    const videoCallBtn = document.getElementById('video-call-btn');
    const audioCallBtn = document.getElementById('audio-call-btn');
    const endBtn = document.getElementById('end-btn');
    const callStatus = document.getElementById('call-status');

    // extra buttons
    const muteBtn = document.getElementById('mute-btn');
    const videoToggleBtn = document.getElementById('video-toggle-btn');
    const cameraSwitchBtn = document.getElementById('camera-switch-btn');
    const speakerBtn = document.getElementById('speaker-btn');

    const socket = io();
    let peerConnection;
    let localStream;
    let isMuted = false;
    let videoEnabled = true;
    let usingFront = true;
    let speakerOn = false;

    const servers = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] };

    videoCallBtn.addEventListener('click', () => startCall({ video: true, audio: true }));
    audioCallBtn.addEventListener('click', () => startCall({ video: false, audio: true }));
    endBtn.addEventListener('click', endCall);

    // тЬЕ Mute toggle
    muteBtn.onclick = () => {
      if (localStream) {
        isMuted = !isMuted;
        localStream.getAudioTracks()[0].enabled = !isMuted;
        muteBtn.innerText = isMuted ? "ЁЯФИ рдЕрдирдореНрдпреВрдЯ" : "ЁЯФЗ рдореНрдпреВрдЯ";
      }
    };

    // тЬЕ Video toggle
    videoToggleBtn.onclick = () => {
      if (localStream) {
        videoEnabled = !videoEnabled;
        localStream.getVideoTracks()[0].enabled = videoEnabled;
        videoToggleBtn.innerText = videoEnabled ? "ЁЯУ╖ рдмрдВрдж" : "ЁЯУ╖ рдЪрд╛рд▓реВ";
      }
    };

    // тЬЕ Camera switch
    cameraSwitchBtn.onclick = async () => {
      if (!localStream) return;
      usingFront = !usingFront;
      const newStream = await navigator.mediaDevices.getUserMedia({
        video: { facingMode: usingFront ? "user" : "environment" },
        audio: true
      });
      const newVideoTrack = newStream.getVideoTracks()[0];

      const sender = peerConnection.getSenders().find(s => s.track.kind === "video");
      sender.replaceTrack(newVideoTrack);

      localStream.getTracks().forEach(track => track.stop());
      localStream = newStream;
      localVideo.srcObject = localStream;
    };

    // тЬЕ Speaker toggle (mobile browsers рдореЗрдВ limited support)
    speakerBtn.onclick = () => {
      speakerOn = !speakerOn;
      remoteVideo.muted = !speakerOn;
      speakerBtn.innerText = speakerOn ? "ЁЯФК рд╕реНрдкреАрдХрд░" : "ЁЯФИ рдЗрдпрд░рдкреАрд╕";
    };

    // тЬЕ FULL SCREEN (mobile browsers рдореЗрдВ limited support)
function toggleFullScreen() {
  let video = document.getElementById("remoteVideo");
  if (!document.fullscreenElement) {
    video.requestFullscreen().catch(err => {
      alert(`Error: ${err.message}`);
    });
  } else {
    document.exitFullscreen();
  }
}


    

    async function startCall(mediaConstraints) {
      videoCallBtn.style.display = 'none';
      audioCallBtn.style.display = 'none';
      endBtn.style.display = 'inline-block';
      muteBtn.style.display = videoToggleBtn.style.display = cameraSwitchBtn.style.display = speakerBtn.style.display = "inline-block";
      callStatus.innerText = "рдХреЙрд▓ рд╢реБрд░реВ рд╣реЛ рд░рд╣реА рд╣реИ...";

      try {
        localStream = await navigator.mediaDevices.getUserMedia(mediaConstraints);
        localVideo.srcObject = localStream;

        peerConnection = new RTCPeerConnection(servers);
        localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));

        peerConnection.ontrack = (event) => {
          if (event.streams && event.streams[0]) {
            remoteVideo.srcObject = event.streams[0];
            callStatus.innerText = "ЁЯУЮ рдХреЙрд▓ рдХрдиреЗрдХреНрдЯреЗрдб";
          }
        };

        peerConnection.onicecandidate = (event) => {
          if (event.candidate) socket.emit('ice-candidate', event.candidate);
        };

        peerConnection.onconnectionstatechange = () => {
          if (["disconnected","closed","failed"].includes(peerConnection.connectionState)) {
            callStatus.innerText = "тЭМ рдХреЙрд▓ рдХрдЯ рдЧрдИ";
            endCall();
          }
        };

        const offer = await peerConnection.createOffer();
        await peerConnection.setLocalDescription(offer);
        socket.emit('offer', offer);

      } catch (error) {
        console.error('рдХреЙрд▓ рд╢реБрд░реВ рдХрд░рдиреЗ рдореЗрдВ рддреНрд░реБрдЯрд┐:', error);
        alert('рдХреЙрд▓ рд╢реБрд░реВ рдирд╣реАрдВ рд╣реЛ рд╕рдХреАред рдХреГрдкрдпрд╛ рдЕрдиреБрдорддрд┐ рджреЗрдВред');
        endCall();
      }
    }

    async function endCall() {
      if (peerConnection) {
        peerConnection.close();
        peerConnection = null;
      }
      if (localStream) {
        localStream.getTracks().forEach(track => track.stop());
        localStream = null;
      }
      localVideo.srcObject = null;
      remoteVideo.srcObject = null;

      videoCallBtn.style.display = 'inline-block';
      audioCallBtn.style.display = 'inline-block';
      endBtn.style.display = 'none';
      muteBtn.style.display = videoToggleBtn.style.display = cameraSwitchBtn.style.display = speakerBtn.style.display = "none";

      callStatus.innerText = "тЭМ рдХреЙрд▓ рд╕рдорд╛рдкреНрдд рд╣реБрдИ";
      socket.emit('call-ended');
    }

    // тЬЕ Incoming offer
    socket.on('offer', async (offer) => {
      const isReady = confirm('ЁЯУЮ рдПрдХ рдХреЙрд▓ рдЖ рд░рд╣реА рд╣реИред рдХреНрдпрд╛ рдЖрдк рдЙрддреНрддрд░ рджреЗрдирд╛ рдЪрд╛рд╣рддреЗ рд╣реИрдВ?');
      if (isReady) {
        videoCallBtn.style.display = 'none';
        audioCallBtn.style.display = 'none';
        endBtn.style.display = 'inline-block';
        muteBtn.style.display = videoToggleBtn.style.display = cameraSwitchBtn.style.display = speakerBtn.style.display = "inline-block";
        callStatus.innerText = "рдХреЙрд▓ рдХрдиреЗрдХреНрдЯ рд╣реЛ рд░рд╣реА рд╣реИ...";

        try {
          const mediaConstraints = offer.sdp.includes('m=video') ? { video: true, audio: true } : { video: false, audio: true };
          localStream = await navigator.mediaDevices.getUserMedia(mediaConstraints);
          localVideo.srcObject = localStream;
          
          peerConnection = new RTCPeerConnection(servers);
          localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));

          peerConnection.ontrack = (event) => {
            if (event.streams && event.streams[0]) {
              remoteVideo.srcObject = event.streams[0];
              callStatus.innerText = "ЁЯУЮ рдХреЙрд▓ рдХрдиреЗрдХреНрдЯреЗрдб";
            }
          };

          peerConnection.onicecandidate = (event) => {
            if (event.candidate) socket.emit('ice-candidate', event.candidate);
          };

          peerConnection.onconnectionstatechange = () => {
            if (["disconnected","closed","failed"].includes(peerConnection.connectionState)) {
              callStatus.innerText = "тЭМ рдХреЙрд▓ рдХрдЯ рдЧрдИ";
              endCall();
            }
          };

          await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));
          const answer = await peerConnection.createAnswer();
          await peerConnection.setLocalDescription(answer);
          socket.emit('answer', answer);
        } catch (error) {
          console.error('рдХреЙрд▓ рдХрд╛ рдЙрддреНрддрд░ рджреЗрдиреЗ рдореЗрдВ рддреНрд░реБрдЯрд┐:', error);
          endCall();
        }
      } else {
        callStatus.innerText = "рдХреЙрд▓ рдЕрд╕реНрд╡реАрдХрд╛рд░ рдХреА рдЧрдИ";
      }
    });

    socket.on('answer', async (answer) => {
      if (peerConnection && !peerConnection.currentRemoteDescription) {
        await peerConnection.setRemoteDescription(new RTCSessionDescription(answer));
      }
    });

    socket.on('ice-candidate', async (candidate) => {
      if (peerConnection) {
        try {
          await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
        } catch (e) {
          console.error('ICE Candidate рдЬреЛрдбрд╝рдиреЗ рдореЗрдВ рддреНрд░реБрдЯрд┐', e);
        }
      }
    });

    socket.on('call-ended', () => {
      callStatus.innerText = "тЭМ рдХреЙрд▓ рджреВрд╕рд░реА рдУрд░ рд╕реЗ рд╕рдорд╛рдкреНрдд рд╣реБрдИ";
      endCall();
    });
  </script>
</body>
</html>
