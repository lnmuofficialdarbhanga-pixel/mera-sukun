<!DOCTYPE html>
<html lang="hi">
<head>
  <meta charset="UTF-8">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>‡§™‡•ç‡§∞‡§æ‡§á‡§µ‡•á‡§ü ‡§ï‡•â‡§≤</title>
  <style>
    body {
      font-family: 'Segoe UI', sans-serif;
      text-align: center;
      background: linear-gradient(135deg, #667eea, #764ba2);
      margin: 0; padding: 20px;
      color: white;
    }
    h1 { margin-bottom: 10px; }
    .status { font-size: 18px; margin-bottom: 20px; font-weight: bold; }
    .video-container { display: flex; justify-content: center; gap: 20px; margin-bottom: 20px; }
    video {
      width: 45%; max-width: 500px;
      border-radius: 5px;
      border: 1px solid rgba(255,255,255,0.3);
      box-shadow: 0 8px 20px rgba(0,0,0,0.3);
      background: black;
    }
    .controls { display: none; flex-wrap: wrap; justify-content: center; gap: 10px; }
    button {
      padding: 12px 20px; font-size: 15px; border: none;
      border-radius: 25px; cursor: pointer; transition: 0.3s;
      font-weight: bold;
    }
    button:hover { transform: scale(1.05); }
    #video-call-btn { background: #00c853; color: white; }
    #audio-call-btn { background: #2196F3; color: white; }
    #end-btn { background: #f44336; color: white; display: none; }
    .extra { background: #333; color: white; display: none; }
    #login-section { margin-top: 50px; }
    #login-btn { background: #ff9800; color: white; }
    #logout-btn { background: #e91e63; color: white; display: none; margin-top: 15px; }
    #user-info { margin-top: 15px; font-size: 16px; font-weight: bold; }

    /* üîí Lock Screen */
    #lock-screen {
      position: fixed;
      top:0; left:0; right:0; bottom:0;
      background: rgba(0,0,0,0.94);
      display: none; flex-direction: column;
      justify-content: center; align-items: center;
      z-index: 9999;
      color: white;
      padding: 20px;
    }
    #lock-screen input {
      padding: 10px;
      border-radius: 5px;
      border: none;
      font-size: 16px;
      text-align: center;
      margin-bottom: 10px;
      width: 220px;
    }
    #unlock-btn {
      background: #4caf50; color:white;
      padding: 8px 20px;
      border:none; border-radius:5px;
      cursor:pointer; font-weight:bold;
    }

    /* small responsive */
    @media (max-width:700px) {
      .video-container { flex-direction: column; }
      video { width: 90%; }
    }
  </style>
</head>
<body>
  <h1>üîí ‡§™‡•ç‡§∞‡§æ‡§á‡§µ‡•á‡§ü ‡§ï‡•â‡§≤</h1>
  <div id="login-section">
    <button id="login-btn"><i class="fab fa-google"></i> Google ‡§∏‡•á ‡§≤‡•â‡§ó‡§ø‡§®</button>
    <div id="user-info"></div>
    <button id="logout-btn">üö™ ‡§≤‡•â‡§ó‡§Ü‡§â‡§ü</button>
  </div>

  <div class="status" id="call-status">‡§ï‡•ã‡§à ‡§ï‡•â‡§≤ ‡§∂‡•Å‡§∞‡•Ç ‡§®‡§π‡•Ä‡§Ç ‡§π‡•à</div>

  <div class="video-container">
    <video id="local-video" autoplay muted playsinline></video>
    <video id="remote-video" autoplay playsinline></video>
  </div>

  <div class="controls">
    <button id="video-call-btn"><i class="fas fa-video"></i> ‡§µ‡•Ä‡§°‡§ø‡§Ø‡•ã ‡§ï‡•â‡§≤</button>
    <button id="audio-call-btn"><i class="fas fa-microphone"></i> ‡§ë‡§°‡§ø‡§Ø‡•ã ‡§ï‡•â‡§≤</button>
    <button id="end-btn">‡§ï‡•â‡§≤ ‡§∏‡§Æ‡§æ‡§™‡•ç‡§§ ‡§ï‡§∞‡•á‡§Ç</button>
    <!-- Extra Controls -->
    <button id="mute-btn" class="extra">üîá ‡§Æ‡•ç‡§Ø‡•Ç‡§ü</button>
    <button id="video-toggle-btn" class="extra">üì∑ ‡§¨‡§Ç‡§¶</button>
    <button id="camera-switch-btn" class="extra">üîÑ ‡§ï‡•à‡§Æ‡§∞‡§æ</button>
    <button id="speaker-btn" class="extra">üîä ‡§∏‡•ç‡§™‡•Ä‡§ï‡§∞</button>
  </div>

  <!-- üîí Lock Screen -->
  <div id="lock-screen">
    <h2>üîí ‡§™‡•á‡§ú ‡§≤‡•â‡§ï ‡§π‡•à</h2>
    <input type="password" id="lock-password" placeholder="‡§™‡§æ‡§∏‡§µ‡§∞‡•ç‡§° ‡§¶‡§∞‡•ç‡§ú ‡§ï‡§∞‡•á‡§Ç">
    <button id="unlock-btn">Unlock</button>
  </div>

  <!-- Firebase SDK -->
  <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-auth.js"></script>
  <script>
    const firebaseConfig = {
      apiKey: "AIzaSyCacx1JD4PoNCwLvyQBvzY2SisKMTAs7Yo",
      authDomain: "mera-sukun.firebaseapp.com",
      databaseURL: "https://mera-sukun-default-rtdb.firebaseio.com",
      projectId: "mera-sukun",
      storageBucket: "mera-sukun.firebasestorage.app",
      messagingSenderId: "900921074457",
      appId: "1:900921074457:web:41af1ae2c3b1f09631db88"
    };
    firebase.initializeApp(firebaseConfig);
    const auth = firebase.auth();

    // Allowed users (only these two)
    const allowedUsers = {
      "kumarikiransah2001@gmail.com": true,
      "prakashkumarraushan1@gmail.com": true
    };

    const loginBtn = document.getElementById("login-btn");
    const logoutBtn = document.getElementById("logout-btn");
    const userInfo = document.getElementById("user-info");
    const controls = document.querySelector(".controls");

    // variables for current session
    let currentUserEmail = null;
    let targetEmail = null;

    loginBtn.onclick = () => {
      const provider = new firebase.auth.GoogleAuthProvider();
      auth.signInWithPopup(provider).catch(err => alert(err.message));
    };

    logoutBtn.onclick = () => {
      // notify server about unregister (done later in socket)
      if (currentUserEmail) {
        try { socket.emit('unregister', currentUserEmail); } catch(e){ }
      }
      auth.signOut();
    };

    // socket is defined later; we declare variable for use in auth callback
    let socket;

    auth.onAuthStateChanged(user => {
      if (user && allowedUsers[user.email]) {
        currentUserEmail = user.email;
        userInfo.innerHTML = "‚úî ‡§≤‡•â‡§ó‡§ø‡§®: " + user.email;
        loginBtn.style.display = "none";
        logoutBtn.style.display = "inline-block";
        controls.style.display = "flex";

        // decide target (the other allowed one)
        if (user.email === "kumarikiransah2001@gmail.com") {
          targetEmail = "prakashkumarraushan1@gmail.com";
        } else {
          targetEmail = "kumarikiransah2001@gmail.com";
        }

        // connect socket (if not already)
        if (!socket) initSocket();

        // register this user with server
        socket.emit('register', currentUserEmail);

      } else {
        // not allowed or logged out
        currentUserEmail = null;
        targetEmail = null;
        userInfo.innerHTML = "";
        loginBtn.style.display = "inline-block";
        logoutBtn.style.display = "none";
        controls.style.display = "none";
        if (user) {
          alert("‚ùå ‡§Ø‡§π Gmail ‡§Ö‡§≤‡§æ‡§â‡§° ‡§®‡§π‡•Ä‡§Ç ‡§π‡•à!");
          auth.signOut();
        }
      }
    });
  </script>

  <!-- Socket.io & Calling Script -->
  <script src="/socket.io/socket.io.js"></script>
  <script>
    const localVideo = document.getElementById('local-video');
    const remoteVideo = document.getElementById('remote-video');
    const videoCallBtn = document.getElementById('video-call-btn');
    const audioCallBtn = document.getElementById('audio-call-btn');
    const endBtn = document.getElementById('end-btn');
    const callStatus = document.getElementById('call-status');

    const muteBtn = document.getElementById('mute-btn');
    const videoToggleBtn = document.getElementById('video-toggle-btn');
    const cameraSwitchBtn = document.getElementById('camera-switch-btn');
    const speakerBtn = document.getElementById('speaker-btn');

    // lock screen elements
    const lockScreen = document.getElementById('lock-screen');
    const unlockBtn = document.getElementById('unlock-btn');
    const lockPassInput = document.getElementById('lock-password');
    const LOCK_PASSWORD = "8003";

    // state
    let peerConnection;
    let localStream;
    let isMuted = false;
    let videoEnabled = true;
    let usingFront = true;
    let speakerOn = false;
    let callTimer; // 30s timer
    const servers = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] };

    // targeted signaling helpers
    let currentUserEmail = null; // set by firebase auth earlier
    let targetEmail = null;      // set by firebase auth earlier
    let remoteSocketId = null;   // set when an offer/answer arrives (socket id of other peer)

    function showLock() {
      lockScreen.style.display = 'flex';
    }
    function hideLock() {
      lockScreen.style.display = 'none';
      lockPassInput.value = '';
    }

    // initial page locked until user unlocks
    showLock();

    unlockBtn.onclick = () => {
      const pass = lockPassInput.value;
      if (pass === LOCK_PASSWORD) {
        hideLock();
      } else {
        alert('‚ùå ‡§ó‡§≤‡§§ ‡§™‡§æ‡§∏‡§µ‡§∞‡•ç‡§°!');
      }
    };

    // lock on visibility change (new tab, minimize)
    document.addEventListener("visibilitychange", () => {
      if (document.hidden) showLock();
    });
    // lock on offline
    window.addEventListener("offline", showLock);

    // Initialize socket & handlers (called after login)
    function initSocket() {
      socket = io();

      socket.on('connect', () => {
        console.log('Socket connected', socket.id);
        // if already logged in register again
        if (typeof firebase !== 'undefined' && firebase.auth && firebase.auth().currentUser) {
          const u = firebase.auth().currentUser;
          if (u && u.email) {
            currentUserEmail = u.email;
            socket.emit('register', currentUserEmail);
          }
        }
      });

      socket.on('user-unavailable', (data) => {
        alert(data.message || 'User not available');
        // end call UI cleanup if needed
        endCall();
      });

      // Offer received (from targeted caller)
      socket.on('offer', async ({ offer, from, fromEmail }) => {
        // if not logged or not allowed -> ignore
        const u = (firebase.auth().currentUser && firebase.auth().currentUser.email) || null;
        if (!u || !u.email || !(['kumarikiransah2001@gmail.com','prakashkumarraushan1@gmail.com'].includes(u.email))) {
          console.log('Offer received but user not authorized. Ignoring.');
          return;
        }

        // store who called (socket id) so we can reply
        remoteSocketId = from;

        const isReady = confirm('üìû ‡§è‡§ï ‡§ï‡•â‡§≤ ‡§Ü ‡§∞‡§π‡•Ä ‡§π‡•à‡•§ ‡§ï‡•ç‡§Ø‡§æ ‡§Ü‡§™ ‡§â‡§§‡•ç‡§§‡§∞ ‡§¶‡•á‡§®‡§æ ‡§ö‡§æ‡§π‡§§‡•á ‡§π‡•à‡§Ç?');
        if (!isReady) {
          callStatus.innerText = "‡§ï‡•â‡§≤ ‡§Ö‡§∏‡•ç‡§µ‡•Ä‡§ï‡§æ‡§∞ ‡§ï‡•Ä ‡§ó‡§à";
          return;
        }

        clearTimeout(callTimer);
        videoCallBtn.style.display = 'none';
        audioCallBtn.style.display = 'none';
        endBtn.style.display = 'inline-block';
        muteBtn.style.display = videoToggleBtn.style.display = cameraSwitchBtn.style.display = speakerBtn.style.display = "inline-block";
        callStatus.innerText = "‡§ï‡•â‡§≤ ‡§ï‡§®‡•á‡§ï‡•ç‡§ü ‡§π‡•ã ‡§∞‡§π‡•Ä ‡§π‡•à...";

        try {
          const mediaConstraints = offer.sdp && offer.sdp.includes('m=video') ? { video: true, audio: true } : { video: false, audio: true };
          localStream = await navigator.mediaDevices.getUserMedia(mediaConstraints);
          localVideo.srcObject = localStream;

          peerConnection = new RTCPeerConnection(servers);
          localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));

          peerConnection.ontrack = (event) => {
            if (event.streams && event.streams[0]) {
              remoteVideo.srcObject = event.streams[0];
              callStatus.innerText = "üìû ‡§ï‡•â‡§≤ ‡§ï‡§®‡•á‡§ï‡•ç‡§ü‡•á‡§°";
              clearTimeout(callTimer);
            }
          };

          peerConnection.onicecandidate = (event) => {
            if (event.candidate) {
              // send candidate to caller using its socket id
              socket.emit('ice-candidate', { candidate: event.candidate, targetId: remoteSocketId });
            }
          };

          peerConnection.onconnectionstatechange = () => {
            if (["disconnected","closed","failed"].includes(peerConnection.connectionState)) {
              callStatus.innerText = "‡§ï‡•â‡§≤ ‡§ï‡§ü ‡§ó‡§à";
              endCall();
            }
          };

          await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));
          const answer = await peerConnection.createAnswer();
          await peerConnection.setLocalDescription(answer);

          // send answer to caller (targetId = caller socket id)
          socket.emit('answer', { answer, targetId: remoteSocketId });

        } catch (error) {
          console.error('‡§ï‡•â‡§≤ ‡§ï‡§æ ‡§â‡§§‡•ç‡§§‡§∞ ‡§¶‡•á‡§®‡•á ‡§Æ‡•á‡§Ç ‡§§‡•ç‡§∞‡•Å‡§ü‡§ø:', error);
          endCall();
        }
      });

      // Answer received (from callee)
      socket.on('answer', async ({ answer, from }) => {
        if (peerConnection && !peerConnection.currentRemoteDescription) {
          try {
            await peerConnection.setRemoteDescription(new RTCSessionDescription(answer));
            // now we know remote socket id (callee)
            remoteSocketId = from;
          } catch (e) {
            console.error('Answer set error', e);
          }
        }
      });

      // ICE candidate received
      socket.on('ice-candidate', async ({ candidate, from }) => {
        if (peerConnection) {
          try {
            await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
          } catch (e) {
            console.error('ICE Candidate ‡§ú‡•ã‡§°‡§º‡§®‡•á ‡§Æ‡•á‡§Ç ‡§§‡•ç‡§∞‡•Å‡§ü‡§ø', e);
          }
        }
      });

      // call ended by remote
      socket.on('call-ended', () => {
        callStatus.innerText = "‡§ï‡•â‡§≤ ‡§¶‡•Ç‡§∏‡§∞‡•Ä ‡§ì‡§∞ ‡§∏‡•á ‡§∏‡§Æ‡§æ‡§™‡•ç‡§§ ‡§π‡•Å‡§à";
        endCall();
      });
    }

    // core UI actions
    videoCallBtn.addEventListener('click', () => startCall({ video: true, audio: true }));
    audioCallBtn.addEventListener('click', () => startCall({ video: false, audio: true }));
    endBtn.addEventListener('click', () => {
      // notify remote if known
      if (remoteSocketId) {
        socket.emit('call-ended', { targetId: remoteSocketId });
      } else if (targetEmail) {
        socket.emit('call-ended', { targetEmail });
      } else {
        socket.emit('call-ended', {});
      }
      endCall();
    });

    muteBtn.onclick = () => {
      if (localStream) {
        isMuted = !isMuted;
        localStream.getAudioTracks()[0].enabled = !isMuted;
        muteBtn.innerText = isMuted ? "üîà ‡§Ö‡§®‡§Æ‡•ç‡§Ø‡•Ç‡§ü" : "üîá ‡§Æ‡•ç‡§Ø‡•Ç‡§ü";
      }
    };

    videoToggleBtn.onclick = () => {
      if (localStream && localStream.getVideoTracks().length) {
        videoEnabled = !videoEnabled;
        localStream.getVideoTracks()[0].enabled = videoEnabled;
        videoToggleBtn.innerText = videoEnabled ? "üì∑ ‡§¨‡§Ç‡§¶" : "üì∑ ‡§ö‡§æ‡§≤‡•Ç";
      }
    };

    cameraSwitchBtn.onclick = async () => {
      if (!localStream) return;
      usingFront = !usingFront;
      const newStream = await navigator.mediaDevices.getUserMedia({
        video: { facingMode: usingFront ? "user" : "environment" },
        audio: true
      });
      const newVideoTrack = newStream.getVideoTracks()[0];
      const sender = peerConnection.getSenders().find(s => s.track && s.track.kind === "video");
      if (sender) sender.replaceTrack(newVideoTrack);

      localStream.getTracks().forEach(track => track.stop());
      localStream = newStream;
      localVideo.srcObject = localStream;
    };

    speakerBtn.onclick = () => {
      speakerOn = !speakerOn;
      remoteVideo.muted = !speakerOn;
      speakerBtn.innerText = speakerOn ? "üîä ‡§∏‡•ç‡§™‡•Ä‡§ï‡§∞" : "üîà ‡§á‡§Ø‡§∞‡§™‡•Ä‡§∏";
    };

    async function startCall(mediaConstraints) {
      // only allow when logged in and targetEmail known
      const user = (firebase.auth().currentUser && firebase.auth().currentUser.email) || null;
      if (!user || !(['kumarikiransah2001@gmail.com','prakashkumarraushan1@gmail.com'].includes(user))) {
        alert('‡§ï‡•É‡§™‡§Ø‡§æ ‡§™‡§π‡§≤‡•á ‡§≤‡•â‡§ó‡§ø‡§® ‡§ï‡§∞‡•á‡§Ç ‡§î‡§∞ ‡§∏‡§π‡•Ä ‡§â‡§™‡§Ø‡•ã‡§ó‡§ï‡§∞‡•ç‡§§‡§æ ‡§π‡•ã‡§Ç‡•§');
        return;
      }

      videoCallBtn.style.display = 'none';
      audioCallBtn.style.display = 'none';
      endBtn.style.display = 'inline-block';
      muteBtn.style.display = videoToggleBtn.style.display = cameraSwitchBtn.style.display = speakerBtn.style.display = "inline-block";
      callStatus.innerText = "‡§ï‡•â‡§≤ ‡§∂‡•Å‡§∞‡•Ç ‡§π‡•ã ‡§∞‡§π‡•Ä ‡§π‡•à...";

      // start 30s timer -> if remote not connected then lock
      clearTimeout(callTimer);
      callTimer = setTimeout(() => {
        // ‡§Ö‡§ó‡§∞ ‡§Ö‡§≠‡•Ä ‡§§‡§ï remote video ‡§®‡§π‡•Ä‡§Ç ‡§Ü‡§à ‡§π‡•à ‡§§‡•ã lock
        if (!remoteVideo.srcObject) {
          endCall();
          showLock();
        }
      }, 30000);

      try {
        localStream = await navigator.mediaDevices.getUserMedia(mediaConstraints);
        localVideo.srcObject = localStream;

        peerConnection = new RTCPeerConnection(servers);
        localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));

        peerConnection.ontrack = (event) => {
          if (event.streams && event.streams[0]) {
            remoteVideo.srcObject = event.streams[0];
            callStatus.innerText = "üìû ‡§ï‡•â‡§≤ ‡§ï‡§®‡•á‡§ï‡•ç‡§ü‡•á‡§°";
            clearTimeout(callTimer);
          }
        };

        peerConnection.onicecandidate = (event) => {
          if (event.candidate) {
            // try to send candidate: if remoteSocketId known use it, else send using targetEmail
            if (remoteSocketId) {
              socket.emit('ice-candidate', { candidate: event.candidate, targetId: remoteSocketId });
            } else {
              socket.emit('ice-candidate', { candidate: event.candidate, targetEmail: targetEmail });
            }
          }
        };

        peerConnection.onconnectionstatechange = () => {
          if (["disconnected","closed","failed"].includes(peerConnection.connectionState)) {
            callStatus.innerText = "‡§ï‡•â‡§≤ ‡§ï‡§ü ‡§ó‡§à";
            endCall();
          }
        };

        const offer = await peerConnection.createOffer();
        await peerConnection.setLocalDescription(offer);

        // send offer to targetEmail (server will forward only to registered socket)
        socket.emit('offer', { offer, targetEmail });

      } catch (error) {
        console.error('‡§ï‡•â‡§≤ ‡§∂‡•Å‡§∞‡•Ç ‡§ï‡§∞‡§®‡•á ‡§Æ‡•á‡§Ç ‡§§‡•ç‡§∞‡•Å‡§ü‡§ø:', error);
        alert('‡§ï‡•â‡§≤ ‡§∂‡•Å‡§∞‡•Ç ‡§®‡§π‡•Ä‡§Ç ‡§π‡•ã ‡§∏‡§ï‡•Ä‡•§ ‡§ï‡•É‡§™‡§Ø‡§æ ‡§Ö‡§®‡•Å‡§Æ‡§§‡§ø ‡§¶‡•á‡§Ç‡•§');
        endCall();
      }
    }

    async function endCall() {
      clearTimeout(callTimer);
      if (peerConnection) {
        try { peerConnection.close(); } catch(e){ }
        peerConnection = null;
      }
      if (localStream) {
        localStream.getTracks().forEach(track => track.stop());
        localStream = null;
      }
      localVideo.srcObject = null;
      remoteVideo.srcObject = null;

      videoCallBtn.style.display = 'inline-block';
      audioCallBtn.style.display = 'inline-block';
      endBtn.style.display = 'none';
      muteBtn.style.display = videoToggleBtn.style.display = cameraSwitchBtn.style.display = speakerBtn.style.display = "none";

      callStatus.innerText = "‡§ï‡•â‡§≤ ‡§∏‡§Æ‡§æ‡§™‡•ç‡§§ ‡§π‡•Å‡§à";

      // notify remote
      if (remoteSocketId) {
        socket.emit('call-ended', { targetId: remoteSocketId });
      } else if (targetEmail) {
        socket.emit('call-ended', { targetEmail });
      } else {
        socket.emit('call-ended', {});
      }

      remoteSocketId = null;
    }

    // unload cleanup
    window.addEventListener('beforeunload', () => {
      try {
        if (firebase && firebase.auth && firebase.auth().currentUser && firebase.auth().currentUser.email) {
          socket.emit('unregister', firebase.auth().currentUser.email);
        }
      } catch(e){}
    });
  </script>
</body>
</html>
