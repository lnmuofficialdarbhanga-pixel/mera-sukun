<!DOCTYPE html>
<html lang="hi">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>‡§™‡•ç‡§∞‡§æ‡§á‡§µ‡•á‡§ü ‡§ï‡•â‡§≤</title>
  <style>
    body {
      font-family: 'Segoe UI', sans-serif;
      text-align: center;
      background: linear-gradient(135deg, #667eea, #764ba2);
      margin: 0; padding: 20px;
      color: white;
    }
    h1 { margin-bottom: 10px; }
    .status { font-size: 18px; margin-bottom: 20px; font-weight: bold; }
    .video-container { display: flex; justify-content: center; gap: 20px; margin-bottom: 20px; }
    video {
      width: 45%; max-width: 500px;
      border-radius: 15px;
      border: 3px solid rgba(255,255,255,0.3);
      box-shadow: 0 8px 20px rgba(0,0,0,0.3);
      background: black;
    }
    .controls { display: flex; flex-wrap: wrap; justify-content: center; gap: 10px; }
    button {
      padding: 12px 20px; font-size: 15px; border: none;
      border-radius: 25px; cursor: pointer; transition: 0.3s;
      font-weight: bold;
    }
    button:hover { transform: scale(1.05); }
    #video-call-btn { background: #00c853; color: white; }
    #audio-call-btn { background: #2196F3; color: white; }
    #end-btn { background: #f44336; color: white; display: none; }
    .extra { background: #333; color: white; display: none; }
  </style>
</head>
<body>
  <h1></h1>
  <div class="status" id="call-status">‡§ï‡•ã‡§à ‡§ï‡•â‡§≤ ‡§∂‡•Å‡§∞‡•Ç ‡§®‡§π‡•Ä‡§Ç ‡§π‡•à</div>

  <div class="video-container">
    <video id="local-video" autoplay muted playsinline></video>
    <video id="remote-video" autoplay playsinline></video>
  </div>

  <div class="controls">
    <button id="video-call-btn">
  <i class="fas fa-video"></i> ‡§µ‡•Ä‡§°‡§ø‡§Ø‡•ã ‡§ï‡•â‡§≤
</button>
    <button id="audio-call-btn">
  <i class="fas fa-microphone"></i> ‡§ë‡§°‡§ø‡§Ø‡•ã ‡§ï‡•â‡§≤
</button>
    <button id="end-btn">‡§ï‡•â‡§≤ ‡§∏‡§Æ‡§æ‡§™‡•ç‡§§ ‡§ï‡§∞‡•á‡§Ç</button>
    <!-- Extra Controls -->
    <button id="mute-btn" class="extra">üîá ‡§Æ‡•ç‡§Ø‡•Ç‡§ü</button>
    <button id="video-toggle-btn" class="extra">üì∑ ‡§¨‡§Ç‡§¶</button>
    <button id="camera-switch-btn" class="extra">üîÑ ‡§ï‡•à‡§Æ‡§∞‡§æ</button>
    <button id="speaker-btn" class="extra">üîä ‡§∏‡•ç‡§™‡•Ä‡§ï‡§∞</button>
  </div>

  <script src="/socket.io/socket.io.js"></script>
  <script>
    const localVideo = document.getElementById('local-video');
    const remoteVideo = document.getElementById('remote-video');
    const videoCallBtn = document.getElementById('video-call-btn');
    const audioCallBtn = document.getElementById('audio-call-btn');
    const endBtn = document.getElementById('end-btn');
    const callStatus = document.getElementById('call-status');

    // extra buttons
    const muteBtn = document.getElementById('mute-btn');
    const videoToggleBtn = document.getElementById('video-toggle-btn');
    const cameraSwitchBtn = document.getElementById('camera-switch-btn');
    const speakerBtn = document.getElementById('speaker-btn');

    const socket = io();
    let peerConnection;
    let localStream;
    let isMuted = false;
    let videoEnabled = true;
    let usingFront = true;
    let speakerOn = false;

    const servers = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] };

    videoCallBtn.addEventListener('click', () => startCall({ video: true, audio: true }));
    audioCallBtn.addEventListener('click', () => startCall({ video: false, audio: true }));
    endBtn.addEventListener('click', endCall);

    // ‚úÖ Mute toggle
    muteBtn.onclick = () => {
      if (localStream) {
        isMuted = !isMuted;
        localStream.getAudioTracks()[0].enabled = !isMuted;
        muteBtn.innerText = isMuted ? "üîà ‡§Ö‡§®‡§Æ‡•ç‡§Ø‡•Ç‡§ü" : "üîá ‡§Æ‡•ç‡§Ø‡•Ç‡§ü";
      }
    };

    // ‚úÖ Video toggle
    videoToggleBtn.onclick = () => {
      if (localStream) {
        videoEnabled = !videoEnabled;
        localStream.getVideoTracks()[0].enabled = videoEnabled;
        videoToggleBtn.innerText = videoEnabled ? "üì∑ ‡§¨‡§Ç‡§¶" : "üì∑ ‡§ö‡§æ‡§≤‡•Ç";
      }
    };

    // ‚úÖ Camera switch
    cameraSwitchBtn.onclick = async () => {
      if (!localStream) return;
      usingFront = !usingFront;
      const newStream = await navigator.mediaDevices.getUserMedia({
        video: { facingMode: usingFront ? "user" : "environment" },
        audio: true
      });
      const newVideoTrack = newStream.getVideoTracks()[0];

      const sender = peerConnection.getSenders().find(s => s.track.kind === "video");
      sender.replaceTrack(newVideoTrack);

      localStream.getTracks().forEach(track => track.stop());
      localStream = newStream;
      localVideo.srcObject = localStream;
    };

    // ‚úÖ Speaker toggle (mobile browsers ‡§Æ‡•á‡§Ç limited support)
    speakerBtn.onclick = () => {
      speakerOn = !speakerOn;
      remoteVideo.muted = !speakerOn;
      speakerBtn.innerText = speakerOn ? "üîä ‡§∏‡•ç‡§™‡•Ä‡§ï‡§∞" : "üîà ‡§á‡§Ø‡§∞‡§™‡•Ä‡§∏";
    };

    async function startCall(mediaConstraints) {
      videoCallBtn.style.display = 'none';
      audioCallBtn.style.display = 'none';
      endBtn.style.display = 'inline-block';
      muteBtn.style.display = videoToggleBtn.style.display = cameraSwitchBtn.style.display = speakerBtn.style.display = "inline-block";
      callStatus.innerText = "‡§ï‡•â‡§≤ ‡§∂‡•Å‡§∞‡•Ç ‡§π‡•ã ‡§∞‡§π‡•Ä ‡§π‡•à...";

      try {
        localStream = await navigator.mediaDevices.getUserMedia(mediaConstraints);
        localVideo.srcObject = localStream;

        peerConnection = new RTCPeerConnection(servers);
        localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));

        peerConnection.ontrack = (event) => {
          if (event.streams && event.streams[0]) {
            remoteVideo.srcObject = event.streams[0];
            callStatus.innerText = "üìû ‡§ï‡•â‡§≤ ‡§ï‡§®‡•á‡§ï‡•ç‡§ü‡•á‡§°";
          }
        };

        peerConnection.onicecandidate = (event) => {
          if (event.candidate) socket.emit('ice-candidate', event.candidate);
        };

        peerConnection.onconnectionstatechange = () => {
          if (["disconnected","closed","failed"].includes(peerConnection.connectionState)) {
            callStatus.innerText = "‡§ï‡•â‡§≤ ‡§ï‡§ü ‡§ó‡§à";
            endCall();
          }
        };

        const offer = await peerConnection.createOffer();
        await peerConnection.setLocalDescription(offer);
        socket.emit('offer', offer);

      } catch (error) {
        console.error('‡§ï‡•â‡§≤ ‡§∂‡•Å‡§∞‡•Ç ‡§ï‡§∞‡§®‡•á ‡§Æ‡•á‡§Ç ‡§§‡•ç‡§∞‡•Å‡§ü‡§ø:', error);
        alert('‡§ï‡•â‡§≤ ‡§∂‡•Å‡§∞‡•Ç ‡§®‡§π‡•Ä‡§Ç ‡§π‡•ã ‡§∏‡§ï‡•Ä‡•§ ‡§ï‡•É‡§™‡§Ø‡§æ ‡§Ö‡§®‡•Å‡§Æ‡§§‡§ø ‡§¶‡•á‡§Ç‡•§');
        endCall();
      }
    }

    async function endCall() {
      if (peerConnection) {
        peerConnection.close();
        peerConnection = null;
      }
      if (localStream) {
        localStream.getTracks().forEach(track => track.stop());
        localStream = null;
      }
      localVideo.srcObject = null;
      remoteVideo.srcObject = null;

      videoCallBtn.style.display = 'inline-block';
      audioCallBtn.style.display = 'inline-block';
      endBtn.style.display = 'none';
      muteBtn.style.display = videoToggleBtn.style.display = cameraSwitchBtn.style.display = speakerBtn.style.display = "none";

      callStatus.innerText = "‡§ï‡•â‡§≤ ‡§∏‡§Æ‡§æ‡§™‡•ç‡§§ ‡§π‡•Å‡§à";
      socket.emit('call-ended');
    }

    // ‚úÖ Incoming offer
    socket.on('offer', async (offer) => {
      const isReady = confirm('üìû ‡§è‡§ï ‡§ï‡•â‡§≤ ‡§Ü ‡§∞‡§π‡•Ä ‡§π‡•à‡•§ ‡§ï‡•ç‡§Ø‡§æ ‡§Ü‡§™ ‡§â‡§§‡•ç‡§§‡§∞ ‡§¶‡•á‡§®‡§æ ‡§ö‡§æ‡§π‡§§‡•á ‡§π‡•à‡§Ç?');
      if (isReady) {
        videoCallBtn.style.display = 'none';
        audioCallBtn.style.display = 'none';
        endBtn.style.display = 'inline-block';
        muteBtn.style.display = videoToggleBtn.style.display = cameraSwitchBtn.style.display = speakerBtn.style.display = "inline-block";
        callStatus.innerText = "‡§ï‡•â‡§≤ ‡§ï‡§®‡•á‡§ï‡•ç‡§ü ‡§π‡•ã ‡§∞‡§π‡•Ä ‡§π‡•à...";

        try {
          const mediaConstraints = offer.sdp.includes('m=video') ? { video: true, audio: true } : { video: false, audio: true };
          localStream = await navigator.mediaDevices.getUserMedia(mediaConstraints);
          localVideo.srcObject = localStream;
          
          peerConnection = new RTCPeerConnection(servers);
          localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));

          peerConnection.ontrack = (event) => {
            if (event.streams && event.streams[0]) {
              remoteVideo.srcObject = event.streams[0];
              callStatus.innerText = "üìû ‡§ï‡•â‡§≤ ‡§ï‡§®‡•á‡§ï‡•ç‡§ü‡•á‡§°";
            }
          };

          peerConnection.onicecandidate = (event) => {
            if (event.candidate) socket.emit('ice-candidate', event.candidate);
          };

          peerConnection.onconnectionstatechange = () => {
            if (["disconnected","closed","failed"].includes(peerConnection.connectionState)) {
              callStatus.innerText = "‡§ï‡•â‡§≤ ‡§ï‡§ü ‡§ó‡§à";
              endCall();
            }
          };

          await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));
          const answer = await peerConnection.createAnswer();
          await peerConnection.setLocalDescription(answer);
          socket.emit('answer', answer);
        } catch (error) {
          console.error('‡§ï‡•â‡§≤ ‡§ï‡§æ ‡§â‡§§‡•ç‡§§‡§∞ ‡§¶‡•á‡§®‡•á ‡§Æ‡•á‡§Ç ‡§§‡•ç‡§∞‡•Å‡§ü‡§ø:', error);
          endCall();
        }
      } else {
        callStatus.innerText = "‡§ï‡•â‡§≤ ‡§Ö‡§∏‡•ç‡§µ‡•Ä‡§ï‡§æ‡§∞ ‡§ï‡•Ä ‡§ó‡§à";
      }
    });

    socket.on('answer', async (answer) => {
      if (peerConnection && !peerConnection.currentRemoteDescription) {
        await peerConnection.setRemoteDescription(new RTCSessionDescription(answer));
      }
    });

    socket.on('ice-candidate', async (candidate) => {
      if (peerConnection) {
        try {
          await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
        } catch (e) {
          console.error('ICE Candidate ‡§ú‡•ã‡§°‡§º‡§®‡•á ‡§Æ‡•á‡§Ç ‡§§‡•ç‡§∞‡•Å‡§ü‡§ø', e);
        }
      }
    });

    socket.on('call-ended', () => {
      callStatus.innerText = "‡§ï‡•â‡§≤ ‡§¶‡•Ç‡§∏‡§∞‡•Ä ‡§ì‡§∞ ‡§∏‡•á ‡§∏‡§Æ‡§æ‡§™‡•ç‡§§ ‡§π‡•Å‡§à";
      endCall();
    });
  </script>
</body>
</html>
