<!DOCTYPE html>
<html lang="hi">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>‡§™‡•ç‡§∞‡§æ‡§á‡§µ‡•á‡§ü ‡§ï‡•â‡§≤</title>
  <style>
    body {
      font-family: 'Segoe UI', sans-serif;
      text-align: center;
      background: linear-gradient(135deg, #667eea, #764ba2);
      margin: 0; padding: 20px;
      color: white;
    }

    h1 { margin-bottom: 10px; }

    .status {
      font-size: 18px;
      margin-bottom: 20px;
      font-weight: bold;
    }

    .video-container {
      display: flex; justify-content: center; gap: 20px; margin-bottom: 20px;
    }

    video {
      width: 45%; max-width: 500px;
      border-radius: 15px;
      border: 3px solid rgba(255,255,255,0.3);
      box-shadow: 0 8px 20px rgba(0,0,0,0.3);
      background: black;
    }

    .controls {
      display: flex; justify-content: center; gap: 15px;
    }

    button {
      padding: 12px 25px;
      font-size: 16px;
      border: none;
      border-radius: 25px;
      cursor: pointer;
      transition: 0.3s;
      font-weight: bold;
    }

    button:hover { transform: scale(1.05); }

    #video-call-btn { background: #00c853; color: white; }
    #audio-call-btn { background: #2196F3; color: white; }
    #end-btn { background: #f44336; color: white; display: none; }
  </style>
</head>
<body>
  <h1></h1>
  <div class="status" id="call-status">‡§ï‡•ã‡§à ‡§ï‡•â‡§≤ ‡§∂‡•Å‡§∞‡•Ç ‡§®‡§π‡•Ä‡§Ç ‡§π‡•à</div>

  <div class="video-container">
    <video id="local-video" autoplay muted></video>
    <video id="remote-video" autoplay></video>
  </div>

  <div class="controls">
    <button id="video-call-btn">üìπ ‡§µ‡•Ä‡§°‡§ø‡§Ø‡•ã ‡§ï‡•â‡§≤</button>
    <button id="audio-call-btn">üé§ ‡§ë‡§°‡§ø‡§Ø‡•ã ‡§ï‡•â‡§≤</button>
    <button id="end-btn">‚ùå ‡§ï‡•â‡§≤ ‡§∏‡§Æ‡§æ‡§™‡•ç‡§§ ‡§ï‡§∞‡•á‡§Ç</button>
  </div>

  <script src="/socket.io/socket.io.js"></script>
  <script>
    const localVideo = document.getElementById('local-video');
    const remoteVideo = document.getElementById('remote-video');
    const videoCallBtn = document.getElementById('video-call-btn');
    const audioCallBtn = document.getElementById('audio-call-btn');
    const endBtn = document.getElementById('end-btn');
    const callStatus = document.getElementById('call-status');

    const socket = io();
    let peerConnection;
    let localStream;

    const servers = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] };

    videoCallBtn.addEventListener('click', () => startCall({ video: true, audio: true }));
    audioCallBtn.addEventListener('click', () => startCall({ video: false, audio: true }));
    endBtn.addEventListener('click', endCall);

    async function startCall(mediaConstraints) {
      videoCallBtn.style.display = 'none';
      audioCallBtn.style.display = 'none';
      endBtn.style.display = 'inline-block';
      callStatus.innerText = "‡§ï‡•â‡§≤ ‡§∂‡•Å‡§∞‡•Ç ‡§π‡•ã ‡§∞‡§π‡•Ä ‡§π‡•à...";

      try {
        localStream = await navigator.mediaDevices.getUserMedia(mediaConstraints);
        localVideo.srcObject = localStream;

        peerConnection = new RTCPeerConnection(servers);
        localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));

        peerConnection.ontrack = (event) => {
          if (event.streams && event.streams[0]) {
            remoteVideo.srcObject = event.streams[0];
            callStatus.innerText = "üìû ‡§ï‡•â‡§≤ ‡§ï‡§®‡•á‡§ï‡•ç‡§ü‡•á‡§°";
          }
        };

        peerConnection.onicecandidate = (event) => {
          if (event.candidate) socket.emit('ice-candidate', event.candidate);
        };

        peerConnection.onconnectionstatechange = () => {
          if (peerConnection.connectionState === "disconnected" || peerConnection.connectionState === "closed") {
            callStatus.innerText = "‚ùå ‡§ï‡•â‡§≤ ‡§ï‡§ü ‡§ó‡§à";
            endCall();
          }
        };

        const offer = await peerConnection.createOffer();
        await peerConnection.setLocalDescription(offer);
        socket.emit('offer', offer);

      } catch (error) {
        console.error('‡§ï‡•â‡§≤ ‡§∂‡•Å‡§∞‡•Ç ‡§ï‡§∞‡§®‡•á ‡§Æ‡•á‡§Ç ‡§§‡•ç‡§∞‡•Å‡§ü‡§ø:', error);
        alert('‡§ï‡•â‡§≤ ‡§∂‡•Å‡§∞‡•Ç ‡§®‡§π‡•Ä‡§Ç ‡§π‡•ã ‡§∏‡§ï‡•Ä‡•§ ‡§ï‡•É‡§™‡§Ø‡§æ ‡§Ö‡§®‡•Å‡§Æ‡§§‡§ø ‡§¶‡•á‡§Ç‡•§');
        endCall();
      }
    }

    async function endCall() {
      if (peerConnection) {
        peerConnection.close();
        peerConnection = null;
      }
      if (localStream) {
        localStream.getTracks().forEach(track => track.stop());
        localStream = null;
      }
      localVideo.srcObject = null;
      remoteVideo.srcObject = null;

      videoCallBtn.style.display = 'inline-block';
      audioCallBtn.style.display = 'inline-block';
      endBtn.style.display = 'none';

      callStatus.innerText = "‚ùå ‡§ï‡•â‡§≤ ‡§∏‡§Æ‡§æ‡§™‡•ç‡§§ ‡§π‡•Å‡§à";
      socket.emit('call-ended');
    }

    socket.on('offer', async (offer) => {
      const isReady = confirm('üìû ‡§è‡§ï ‡§ï‡•â‡§≤ ‡§Ü ‡§∞‡§π‡•Ä ‡§π‡•à‡•§ ‡§ï‡•ç‡§Ø‡§æ ‡§Ü‡§™ ‡§â‡§§‡•ç‡§§‡§∞ ‡§¶‡•á‡§®‡§æ ‡§ö‡§æ‡§π‡§§‡•á ‡§π‡•à‡§Ç?');
      if (isReady) {
        videoCallBtn.style.display = 'none';
        audioCallBtn.style.display = 'none';
        endBtn.style.display = 'inline-block';
        callStatus.innerText = "‡§ï‡•â‡§≤ ‡§ï‡§®‡•á‡§ï‡•ç‡§ü ‡§π‡•ã ‡§∞‡§π‡•Ä ‡§π‡•à...";

        try {
          const mediaConstraints = offer.sdp.includes('m=video') ? { video: true, audio: true } : { video: false, audio: true };
          localStream = await navigator.mediaDevices.getUserMedia(mediaConstraints);
          localVideo.srcObject = localStream;
          
          peerConnection = new RTCPeerConnection(servers);
          localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));

          peerConnection.ontrack = (event) => {
            if (event.streams && event.streams[0]) {
              remoteVideo.srcObject = event.streams[0];
              callStatus.innerText = "üìû ‡§ï‡•â‡§≤ ‡§ï‡§®‡•á‡§ï‡•ç‡§ü‡•á‡§°";
            }
          };

          peerConnection.onicecandidate = (event) => {
            if (event.candidate) socket.emit('ice-candidate', event.candidate);
          };

          peerConnection.onconnectionstatechange = () => {
            if (peerConnection.connectionState === "disconnected" || peerConnection.connectionState === "closed") {
              callStatus.innerText = "‚ùå ‡§ï‡•â‡§≤ ‡§ï‡§ü ‡§ó‡§à";
              endCall();
            }
          };

          await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));
          const answer = await peerConnection.createAnswer();
          await peerConnection.setLocalDescription(answer);
          socket.emit('answer', answer);
        } catch (error) {
          console.error('‡§ï‡•â‡§≤ ‡§ï‡§æ ‡§â‡§§‡•ç‡§§‡§∞ ‡§¶‡•á‡§®‡•á ‡§Æ‡•á‡§Ç ‡§§‡•ç‡§∞‡•Å‡§ü‡§ø:', error);
          endCall();
        }
      } else {
        console.log('‡§ï‡•â‡§≤ ‡§Ö‡§∏‡•ç‡§µ‡•Ä‡§ï‡§æ‡§∞ ‡§ï‡•Ä ‡§ó‡§à‡•§');
        callStatus.innerText = "‡§ï‡•â‡§≤ ‡§Ö‡§∏‡•ç‡§µ‡•Ä‡§ï‡§æ‡§∞ ‡§ï‡•Ä ‡§ó‡§à";
      }
    });

    socket.on('answer', async (answer) => {
      if (peerConnection && !peerConnection.currentRemoteDescription) {
        await peerConnection.setRemoteDescription(new RTCSessionDescription(answer));
      }
    });

    socket.on('ice-candidate', async (candidate) => {
      if (peerConnection) {
        try {
          await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
        } catch (e) {
          console.error('ICE Candidate ‡§ú‡•ã‡§°‡§º‡§®‡•á ‡§Æ‡•á‡§Ç ‡§§‡•ç‡§∞‡•Å‡§ü‡§ø', e);
        }
      }
    });

    socket.on('call-ended', () => {
      callStatus.innerText = "‚ùå ‡§ï‡•â‡§≤ ‡§¶‡•Ç‡§∏‡§∞‡•Ä ‡§ì‡§∞ ‡§∏‡•á ‡§∏‡§Æ‡§æ‡§™‡•ç‡§§ ‡§π‡•Å‡§à";
      endCall();
    });
  </script>
</body>
</html>
